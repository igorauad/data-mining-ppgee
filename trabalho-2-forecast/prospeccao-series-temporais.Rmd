---
title: "Prospecção Séries Temporais"
author: 'G4: Edinaldo de Alencar / Igor Freire / Ramon Araújo / Ricardo Ribeiro'
date: "16 de outubro de 2014"
output:
  slidy_presentation:
    incremental: true
bibliography: bibliography.bib
---

## Importação da base de dados

Pacote utilizado para leitura em formato de séries temporais:
```{r, message=FALSE}
library(zoo)
```


Importar as bases de dados utilizando `read.zoo`:
```{r}
# Mudar para o diretório onde está a base de dados
setwd(paste("/Users/igorfreire/Documents/Mestrado/UFPA/",
               "/Mineração de Dados/data-mining-ppgee/",
               "/trabalho-2-forecast/", sep="")); 

# Inicialmente ler a base de dados diários como um data frame (através de read.csv)
dataframe_diario <- read.csv(file = "dataset_diario.csv", sep = ";", dec = ",", header = TRUE)
# Em seguida, converter para uma série temporal (lista indexada pela data)
dataset_diario <- zoo(as.matrix(dataframe_diario[, -1:-2]), as.Date(dataframe_diario[,1], format = "%d/%m/%y"))
# Obs: em "format" usa-se y minusculo, pois a data está no formato dd/mm/yy

# A função read.zoo() abaixo não retorna lista com vetores categóricos e numéricos ao mesmo tempo.
# Isto é, se houver dados categóricos e numéricos na base, os numéricos serão convertidos.
# Por isso, a base com dados diários não foi lida diretamente com read.zoo. A base com dados mensais 
# pode ser lida diretamente com read.zoo()
# Ler o .csv como uma série temporal (indexado pela data)
dataset_mensal <- read.zoo(file = "dataset_mensal.csv", sep = ";", dec = ",", header = TRUE, 
        index = 1, tz = "", FUN = as.yearmon, format = "%m/%Y", drop = FALSE)
# index ->  coluna do arquivo .csv que contém a data
# Obs: em "format" usa-se Y maiúsculo, pois a data está no formato mm/yyyy
                    
```

* `dataset_diario` é a base com valores de fluxos diários de 2002 à 2009. 
* `dataset_mensal` é a base com os valores de fluxo mensais de 1992 à 2009. 

### Notar que é necessário definir:

1.  O caractere que separa as entradas no arquivo *.csv* (`sep =`)
2.  O caractere separador de casas decimais do atributo numérico presente nas bases de dados (`dec =`) 

## Informação sobre os dias da semana

**Observar** que a informação sobre os dias da semana é redundante, pois pode ser obtida através de:
```{r}
dia <- weekdays(index(dataset_diario))
```
que tem como resultado, por exemplo, para as 10 primeiras amostras da base:
```{r}
head(dia, 10)
```
o qual pode ser confirmado comparando com as 10 primeiras entradas na coluna "dia" da base:
```{r}
head(dataframe_diario[,2], 10)
```

Por isso, na leitura da base em `dataset_diario` esta coluna foi ignorada.

## Inspeção do conjunto de dados

* Dataset diário:
```{r}
summary(dataset_diario)
```

* Dataset diário:
```{r}
summary(dataset_mensal)
```

## Séries temporais

Converter os dados para o formato de série temporal no R:
```{r}
# Frequency --> numero de observacoes por unidade de tempo 
# define a unidade de tempo (e.g. 12, unidade de tempo = ano)
tsMensal <- ts(dataset_mensal, frequency=12, start=1992)
plot(tsMensal, xlab="Anos", ylab="Fluxo")

# Periodo (unidade de tempo) = ano
tsDiario <- ts(dataset_diario, start=c(2002,1,1), frequency=365)
plot(tsDiario, xlab="Anos", ylab="Fluxo")
```

## Decomposição das séries temporais

Decompor a série temporal em:

* *Trend*: padrão de crescimento ao longo do tempo
* *Seasonal*: padrão recorrente em um determinado período de tempo
* *Irregular* (random): parte irregular (ruidosa), sem padrão sazonal ou tendência 

```{r}
plot(decompose(tsMensal), xlab="Anos")
plot(decompose(tsDiario), xlab="Anos")
```

## Separação dos dados 

Separação da série temporal `tsMensal` em séries contendo dados de treinamento e de teste.

```{r}
tsMensalTrain <- window(tsMensal, end=(2006-0.01)) # De Jan 1992 até Dez 2005
tsMensalTest <- window(tsMensal, start=2006) # De Jan 2006 até Dez 2009
```

Visualização
```{r}
tsMensalTest
```

## Métodos simplísticos

* **Média**: valor futuro predito é a média dos dados históricos
* **Näive**: valor futuro predito é igual ao último dado observado
* **Sazonal**: valor futuro predito é igual dado no período anterior (dada uma divisão em períodos que representa a sazonalidade do conjunto) correspondente. Por exemplo, se a sazonalidade está em anos e os dados são mensais, o valor predito no mês de outubro do ano futuro é igual ao valor no mês de outubro observado no ano passado.
* ***Drift***: valor futuro predito é igual ao último valor observado mais a média da diferença entre dados consecutivos (captura a tendência)

## Estratégia de Avaliação dos Métodos
Apresenta-se a seguir:

* a predição proporcionada por estes métodos (curva vermelha)
* intervalos de predição correspondentes aos níveis de confiança 80% (em azul) e 95% (em cinza).
* acurácias **in-sample** e **out-of-sample**

**Nota**:

* **in-sample**: medida dentro do conjunto no qual os modelos foram treinados.
* **out-of-sample**: medida no conjunto de testes.

Pacote utilizado (ver [@hyndmanForecastingR] e [@practicalMachineLearningForecasting]):
```{r, message=FALSE}
library(forecast)
```

Funções utilizadas:

* `meanf()`
* `naive()`
* `snaive()`
* `rwf()`

Saída: objeto `forecast`, contendo:

* Série Original
* Predições
* Método utilizado
* Intervalos de Predição
* Resíduos

## Acurácia

Medidores usuais:

* ME: Mean error
* MAE: Mean absolute error
* RMSE: Root mean square error
* MAPE: Mean absolute percentage error

Diferentemente do ME, MAE e RMSE, o medidor MAPE é independente da escala.

### MAPE:
$M = \frac{1}{n} \sum \limits_{t=1}^{n} \left| \frac{A_t - F_t}{A_t} \right|,$ 

onde $A_t$ é o valor verdadeiro, $F_t$ é o valor predito e $n$ é o número de amostras temporais preditas.

## Avaliação dos Métodos

#### Série temporal de treinamento
```{r}
# Dados de treinamento
plot(tsMensalTrain)
```

#### Número de meses para os quais deseja-se prever o fluxo
```{r}
mesesAPrever <- 12
```

#### Média
```{r}
# Média
f_mean <- meanf(tsMensalTrain, h=mesesAPrever)
plot(f_mean)
lines(tsMensalTest, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
# Acurácia
accuracy(f_mean, tsMensalTest)
```

#### Näive
```{r}
# Näive
f_naive <- naive(tsMensalTrain, h=mesesAPrever)
plot(f_naive)
lines(tsMensalTest, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
# Acurácia
accuracy(f_naive, tsMensalTest)
```

#### Näive Sazonal
```{r}
# Näive Sazonal
f_seazonal_naive <- snaive(tsMensalTrain, h=mesesAPrever)
plot(f_seazonal_naive)
lines(tsMensalTest, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
# Acurácia
accuracy(f_seazonal_naive, tsMensalTest)
```

#### Drift
```{r}
# Drift
f_drift <- rwf(tsMensalTrain, drift = TRUE, h=mesesAPrever)
plot(f_drift)
lines(tsMensalTest, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
# Acurácia
accuracy(f_drift, tsMensalTest)
```

## Modelo médias-móveis

Dado no instante $t$ de uma série temporal é dado pelo valor esperado da variável aleatória acrescida do ruído branco no instante $t$ e a soma ponderada do ruído branco em instantes passados.

O número de instantes passados considerados é dado pela ordem do modelo.

### Médias móveis de ordem 3:
```{r}
plot(tsMensalTrain)
lines(ma(tsMensalTrain, order=3), col="red")
```

## Modelo auto regressivo

Dado no instante $t$ de uma série temporal é expresso como a média ponderada dos dados em instantes passados acrescida de ruído branco.

O número de instantes passados considerados é dado pela ordem do modelo.

#### Exemplo:
```{r}
ar_model <- ar(tsMensalTrain)
```

Ordem escolhida automaticamente:
```{r}
ar_model$order
```

Predição:
```{r}
ar_fit <- predict(ar_model, n.ahead = 12)
plot(tsMensalTrain)
lines(ar_fit$pred, col="red")
```

Acurácia:
```{r}
accuracy(ar_fit$pred, tsMensalTest)
```

## ARIMA

* ARMA: autoregressive moving-average - combinação de ambos
* ARIMA: ARMA com um passo de diferenciação

Modelo:
```{r}
arima_model <- auto.arima(tsMensalTrain)
```

Predição:
```{r}
fcast_arima <- forecast(arima_model, h=mesesAPrever)
plot(fcast_arima)
```

Acurácia:
```{r}
accuracy(fcast_arima, tsMensalTest)
```

## Exponential Smoothing
Ver [@HyndmanAthanasopoulos201310]. O mesmo autor possui um livro somente sobre o assunto em [@HyndmanKoehlerOrdSnyder200807].

Modelo:
```{r}
etsMensal <- ets(tsMensalTrain, model="MMM")
# Multiplicative Error
# Multiplicative trend
# Multiplicative Season
```

Prospecção:
```{r}
fcastMensal <- forecast(etsMensal)
```

Comparar predição com valores reais do conjunto de teste:
```{r}
plot(fcastMensal);
lines(tsMensalTest, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
```

Acurácia:
```{r}
accuracy(fcastMensal, tsMensalTest)
```

## Exponential Smoothing Automático

```{r}
etsMensal_auto <- ets(tsMensalTrain)
```

Prospecção:
```{r}
fcastMensal_auto <- forecast(etsMensal_auto)
```

Comparar predição com valores reais do conjunto de teste:
```{r}
plot(fcastMensal_auto); 
lines(tsMensalTest, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
```

Acurácia:
```{r}
accuracy(fcastMensal_auto, tsMensalTest)
```

## Referências