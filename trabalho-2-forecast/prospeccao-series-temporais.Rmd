---
title: "Prospecção Séries Temporais"
author: 'G4: Edinaldo de Alencar / Igor Freire / Ramon Araújo / Ricardo Ribeiro'
date: "28 de outubro de 2014"
output:
  slidy_presentation:
    incremental: true
bibliography: bibliography.bib
---

## Importação da base de dados

Pacote utilizado para leitura em formato de séries temporais:
```{r, message=FALSE}
library(zoo)
```


Importar as bases de dados utilizando `read.zoo`:
```{r, cache=TRUE}
# A base de dados e os scripts R estão no mesmo diretório (o diretório atual)
setwd(paste("~/Documents/Mestrado/UFPA/Mineração de Dados/data-mining-ppgee/trabalho-2-forecast/", sep=""));

# Inicialmente, ler a base de dados diários como um data frame (através de read.csv)
dataframe_diario <- read.csv(file = "dataset_diario.csv", sep = ";", dec = ",", header = TRUE)
# Em seguida, converter para uma série temporal (lista indexada pela data)
dataset_diario <- zoo(as.matrix(dataframe_diario[, -1:-2]), as.Date(dataframe_diario[,1], format = "%d/%m/%y"))
# Obs: em "format" usa-se y minusculo, pois a data está no formato dd/mm/yy

# A função read.zoo() abaixo não retorna lista com vetores categóricos e numéricos ao mesmo tempo.
# Isto é, se houver dados categóricos e numéricos na base, os numéricos serão convertidos.
# Por isso, a base com dados diários não foi lida diretamente com read.zoo. A base com dados mensais 
# pode ser lida diretamente com read.zoo()
# Ler o .csv como uma série temporal (indexado pela data)
dataset_mensal <- read.zoo(file = "dataset_mensal.csv", sep = ";", dec = ",", header = TRUE, 
        index = 1, tz = "", FUN = as.yearmon, format = "%m/%Y", drop = FALSE)
# index ->  coluna do arquivo .csv que contém a data
# Obs: em "format" usa-se Y maiúsculo, pois a data está no formato mm/yyyy
                    
```

* `dataset_diario` é a base com valores de fluxos diários de 2002 a 2009. 
* `dataset_mensal` é a base com os valores de fluxo mensais de 1992 a 2009. 

### Notar que é necessário definir:

1.  O caractere que separa as entradas no arquivo *.csv* (`sep =`)
2.  O caractere separador de casas decimais do atributo numérico presente nas bases de dados (`dec =`)

## Informação sobre os dias da semana

**Observar** que a informação sobre os dias da semana é redundante, pois pode ser obtida através de:
```{r}
dia <- weekdays(index(dataset_diario))
```
que tem como resultado, por exemplo, para as 10 primeiras amostras da base:
```{r}
head(dia, 10)
```
o qual pode ser confirmado comparando com as 10 primeiras entradas na coluna "dia" da base:
```{r}
head(dataframe_diario[,2], 10)
```

Por isso, na leitura da base em `dataset_diario`, esta coluna foi ignorada.

## Inspeção do Conjunto de Dados

* Dataset diário:
```{r}
summary(dataset_diario)
```

* Dataset mensal:
```{r}
summary(dataset_mensal)
```

## Séries Temporais

Conversão dos dados para o formato de série temporal no R.

#### Série Mensal:
```{r, cache=TRUE}
# Frequency --> numero de observações por unidade de tempo 
# define a unidade de tempo (e.g. 12, unidade de tempo = ano)
tsMensal <- ts(dataset_mensal, frequency=12, start=1992)
plot(tsMensal, xlab="Anos", ylab="Fluxo")
```

#### Série Diária:
Série temporal multi-sazonal
```{r, cache=TRUE}
tsDiario <- msts(dataset_diario, seasonal.periods=c(7, 365.25), start=c(2002,1,1))
plot(tsDiario, xlab="Anos", ylab="Fluxo")
```

## Decomposição das séries temporais

Decompor a série temporal em:

* *Trend*: padrão de crescimento ao longo do tempo.
* *Seasonal*: padrão recorrente em um determinado período de tempo.
* *Irregular* (random): parte irregular (ruidosa), sem padrão sazonal ou tendência.

```{r, cache=TRUE}
plot(decompose(tsMensal), xlab="Anos")
plot(decompose(tsDiario), xlab="Anos")
```

* Observações
  1. Clara tendência (trend) de subida.
  2. Sazonalidade de 1 ano.


## Objetivos

Realizar prospecções de curto, médio e longo prazo.

### Curto Prazo
  * 30 Dias
  * 45 Dias
  
Para curto prazo, será utilizada a série temporal com dados diários (`tsDiario`). 
  
### Médio Prazo
  * 4 Meses 
  * 6 Meses
  
### Longo Prazo
  * 1 Ano
  * 2 Anos
  
Para médio e longo prazo, será utilizada a série temporal com dados mensais (`tsMensal`). 
  
## Separação dos dados

Separação da séries temporais em em conjuntos de treinamento e conjunto de testes.

### Curto Prazo
Separação de `tsDiario` em conjuntos de treinamento e teste.

#### 30 dias:
```{r, cache=TRUE}
tsDiarioTrain <- window(tsDiario, end=(2006-0.01)) # De Jan 2002 até Dez 2005
tsDiarioTest30Days <- window(tsDiario, start=c(2006,1), end=c(2006,30)) # De 1/1/2006 a 30/1/2006
```

#### 45 dias:
```{r, cache=TRUE}
# 45 dias a partir De 1/1/2006
tsDiarioTest45Days <- window(tsDiario, start=c(2006,1), end=c(2006,45)) 
```

### Médio/Longo Prazo

#### 4 meses:
Separação de `tsMensal` em conjuntos de treinamento e teste:
```{r, cache=TRUE}
tsMensalTrain <- window(tsMensal, end=c(2005, 12)) # De Jan 1992 até Dez 2005
tsMensalTest4mth <- window(tsMensal, start=2006, end=c(2006,4)) # De Jan 2006 até Mar 2006
```

#### 6 meses:
```{r, cache=TRUE}
tsMensalTest6mth <- window(tsMensal, start=2006, end=c(2006,6)) # De Jan 2006 até Jun 2006
```

#### 1 ano:
```{r, cache=TRUE}
tsMensalTest1yr <- window(tsMensal, start=2006, end=2007) # De Jan 2006 até Jan 2007
```

#### 2 anos:
```{r, cache=TRUE}
tsMensalTest2yr <- window(tsMensal, start=2006, end=(2008)) # De Jan 2006 até Jan 2008
```

## Acurácia

Métricas comparativas usuais:

* ME: Mean Error
* MAE: Mean Absolute Error
* RMSE: Root Mean Square Error
* MAPE: Mean Absolute Percentage Error

Diferentemente do ME, MAE e RMSE, o medidor MAPE é independente da escala.

### MAPE:
$$M = \frac{1}{n} \sum \limits_{t=1}^{n} \left| \frac{A_t - F_t}{A_t} \right|,$$ 

onde $A_t$ é o valor verdadeiro, $F_t$ é o valor predito e $n$ é o número de amostras temporais preditas.

Como desvantagem, o critério MAPE tem comportamento indefinido quando o valor verdadeiro $A_t=0$ (divisão por zero).


## Métodos simplistas

* **Média**: valor futuro predito é a média dos dados históricos.
* **Naïve**: valor futuro predito é igual ao último dado observado.
* **Sazonal**: valor futuro predito é igual dado no período anterior (dada uma divisão em períodos que representa a sazonalidade do conjunto) correspondente. Por exemplo, se a sazonalidade está em anos e os dados são mensais, o valor predito no mês de outubro do ano futuro é igual ao valor no mês de outubro observado no ano passado.
* ***Drift***: valor futuro predito é igual ao último valor observado mais a média da diferença entre dados consecutivos (captura a tendência).

Funções utilizadas na biblioteca `forecast`:

* `meanf()`
* `naive()`
* `snaive()`
* `rwf()`

## Estratégia de Avaliação dos Métodos
Apresenta-se a seguir:

* a predição proporcionada por diferentes métodos (curva vermelha).
* intervalos de predição correspondentes aos níveis de confiança 80% (em azul) e 95% (em cinza).
* acurácias **in-sample** e **out-of-sample**.

**Nota**:

* **in-sample**: medida no conjunto de treinamento.
* **out-of-sample**: medida no conjunto de testes.

Pacote utilizado (ver [@hyndmanForecastingR] e [@practicalMachineLearningForecasting]):
```{r, message=FALSE}
library(forecast)
```

Saída: objeto `forecast`, contendo:
* Série Original
* Predições
* Método utilizado
* Intervalos de Predição
* Resíduos

## Métodos simplistas em prospecções de Curto Prazo

Prospecções através dos métodos simplísticos para um prazo 30 dias.

#### Série temporal de treinamento
  Fluxo diário de Janeiro de 2002 a Dezembro de 2005
```{r, cache=TRUE}
# Dados de treinamento
plot(tsDiarioTrain, xlab="Anos", ylab="Fluxo Diário",)
title("Fluxo diário de treinamento: Jan 2002 a Dez 2005")
```

#### Número de dias para os quais deseja-se prever o fluxo
```{r}
diasAPrever <- 30
```

#### Média
```{r, cache=TRUE}
# Média
f_mean <- meanf(tsDiarioTrain, h=diasAPrever)
plot(f_mean, xlab="Anos", ylab="Fluxo Diario", include=365)
lines(tsDiarioTest30Days, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
# Acurácia
accuracy(f_mean, tsDiarioTest30Days)
```

#### Naïve
```{r, cache=TRUE}
# Naïve
f_naive <- naive(tsDiarioTrain, h=diasAPrever)
plot(f_naive, xlab="Anos", ylab="Fluxo Diario", include=365)
lines(tsDiarioTest30Days, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
# Acurácia
accuracy(f_naive, tsDiarioTest30Days)
```

#### Naïve Sazonal
```{r, cache=TRUE}
# Naïve Sazonal
f_seasonal_naive <- snaive(tsDiarioTrain, h=diasAPrever)
plot(f_seasonal_naive, xlab="Anos", ylab="Fluxo Diario", include=365)
lines(tsDiarioTest30Days, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
# Acurácia
accuracy(f_seasonal_naive, tsDiarioTest30Days)
```

#### Drift
```{r, cache=TRUE}
# Drift
f_drift <- rwf(tsDiarioTrain, drift = TRUE, h=diasAPrever)
plot(f_drift, xlab="Anos", ylab="Fluxo Diario", include=365)
lines(tsDiarioTest30Days, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
# Acurácia
accuracy(f_drift, tsDiarioTest30Days)
```

## Métodos simplistas em prospecções de médio prazo

Prospecções através dos métodos simplísticos para um prazo 4 meses.

#### Série temporal de treinamento
  Fluxo mensal de Janeiro de 2002 a Dezembro de 2005
```{r}
# Dados de treinamento
plot(tsMensalTrain, xlab="Anos", ylab="Fluxo Mensal")
title("Fluxo mensal de treinamento: Jan 2002 a Dez 2005")
```

#### Número de meses para os quais deseja-se prever o fluxo
```{r, cache=TRUE}
mesesAPrever <- 4
```

#### Comparação dos métodos simplísticos
```{r, echo=FALSE, cache=TRUE}
# Média
f_mean <- meanf(tsMensalTrain, h=mesesAPrever)
mape_mean_accuracy <- accuracy(f_mean, tsMensalTest1yr)[,5]
# Naïve
f_naive <- naive(tsMensalTrain, h=mesesAPrever)
mape_naive_accuracy <- accuracy(f_naive, tsMensalTest1yr)[,5]
# Naïve Sazonal
f_seasonal_naive <- snaive(tsMensalTrain, h=mesesAPrever)
mape_naiveseaz_accuracy <- accuracy(f_seasonal_naive, tsMensalTest1yr)[,5]
# Drift
f_drift <- rwf(tsMensalTrain, drift = TRUE, h=mesesAPrever)
mape_drif_accuracy <- accuracy(f_drift, tsMensalTest1yr)[,5]

accuracies <- data.frame(mape_mean_accuracy, 
                         mape_naive_accuracy, 
                         mape_naiveseaz_accuracy,
                         mape_drif_accuracy)

colnames(accuracies) <- c("Mean", "Näive", "N-Sazonal", "Drift")

plot(f_mean)
lines(tsMensalTest6mth, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
plot(f_naive)
lines(tsMensalTest6mth, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
plot(f_seasonal_naive)
lines(tsMensalTest6mth, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
plot(f_drift); 
lines(tsMensalTest6mth, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)

accuracies
```

## Métodos simplistas em prospecções de longo prazo

Prospecções através dos métodos simplísticos para um prazo 1 ano.

#### Série temporal de treinamento
  Fluxo mensal de Janeiro de 2002 a Dezembro de 2005
```{r}
# Dados de treinamento
plot(tsMensalTrain, xlab="Anos", ylab="Fluxo Mensal")
title("Fluxo mensal de treinamento: Jan 2002 a Dez 2005")
```

#### Número de meses para os quais deseja-se prever o fluxo
```{r, cache=TRUE}
mesesAPrever <- 12
```

#### Comparação dos métodos simplísticos
```{r, echo=FALSE, cache=TRUE}
# Média
f_mean <- meanf(tsMensalTrain, h=mesesAPrever)
mape_mean_accuracy <- accuracy(f_mean, tsMensalTest1yr)[,5]
# Naïve
f_naive <- naive(tsMensalTrain, h=mesesAPrever)
mape_naive_accuracy <- accuracy(f_naive, tsMensalTest1yr)[,5]
# Naïve Sazonal
f_seasonal_naive <- snaive(tsMensalTrain, h=mesesAPrever)
mape_naiveseaz_accuracy <- accuracy(f_seasonal_naive, tsMensalTest1yr)[,5]
# Drift
f_drift <- rwf(tsMensalTrain, drift = TRUE, h=mesesAPrever)
mape_drif_accuracy <- accuracy(f_drift, tsMensalTest1yr)[,5]

accuracies <- data.frame(mape_mean_accuracy, 
                         mape_naive_accuracy, 
                         mape_naiveseaz_accuracy,
                         mape_drif_accuracy)

colnames(accuracies) <- c("Mean", "Näive", "N-Sazonal", "Drift")

plot(f_mean)
lines(tsMensalTest1yr, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
plot(f_naive)
lines(tsMensalTest1yr, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
plot(f_seasonal_naive)
lines(tsMensalTest1yr, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
plot(f_drift); 
lines(tsMensalTest1yr, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)

accuracies
```

## Regressão Linear

### 30 dias
```{r, cache=TRUE}
diasAPrever <- 30
reg <- tslm(tsDiarioTrain ~ trend + season)
regfcast <- forecast(reg, h=diasAPrever)
plot(regfcast, xlab="Anos", ylab="Fluxo Diario", include=365)
lines(tsDiarioTest30Days, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
accuracy(regfcast, tsDiarioTest30Days)
```

### 1 Ano
```{r, cache=TRUE}
mesesAPrever <- 12
reg <- tslm(tsMensalTrain ~ trend+season)
regfcast <- forecast(reg, h=mesesAPrever)
accuracy(regfcast, tsMensalTest1yr)
```

## Modelo ARIMA

ARIMA (auto regressive integration moving average)

### Moving-average Modelo médias-móveis

Dado no instante $t$ de uma série temporal é dado pelo valor esperado da variável aleatória acrescida do ruído branco no instante $t$ e a soma ponderada do ruído branco em instantes passados.

O número de instantes passados considerados é dado pela ordem do modelo.

### Médias móveis de ordem 3:
```{r}
plot(tsMensalTrain, xlab="Anos", ylab="Fluxo Mensal")
movAvg <- ma(tsMensalTrain, order=3)
lines(movAvg, col="red")
```

### Auto-regressive - Modelo auto regressivo (AR)
Dado no instante $t$ de uma série temporal é expresso como a média ponderada dos dados em instantes passados acrescida de ruído branco.

O número de instantes passados considerados é dado pela ordem do modelo.

### ARMA

ARMA: autoregressive moving-average - combinação de ambos

### ARIMA
ARIMA: ARMA com um passo de diferenciação

## Método ARIMA em prospecções de curto prazo

### Para 30 dias

```{r}
diasAPrever <- 30
```

Modelo:
```{r}
arima_model_30days <- auto.arima(tsDiarioTrain)
```

Predição:
```{r}
fcast_arima_30days <- forecast(arima_model_30days, h=diasAPrever)
plot(fcast_arima_30days, xlab="Anos", ylab="Fluxo Diário")
lines(tsDiarioTest30Days, col="red")
```

Acurácia:
```{r}
accuracy(fcast_arima_30days, tsDiarioTest30Days)
```

## Método ARIMA em prospecções de médio prazo

### Para 4 meses

```{r}
mesesAPrever <- 4
```

Modelo:
```{r}
arima_model_mensal <- auto.arima(tsMensalTrain)
```

Predição:
```{r}
fcast_arima_4mth <- forecast(arima_model_mensal, h=mesesAPrever)
plot(fcast_arima_4mth, xlab="Anos", ylab="Fluxo Mensal")
lines(tsMensalTest4mth, col="red")
```

Acurácia:
```{r}
accuracy(fcast_arima_4mth, tsMensalTest4mth)
```

### Para 6 meses

```{r}
mesesAPrever <- 6
```

Predição:
```{r, cache=TRUE}
fcast_arima_6mth <- forecast(arima_model_mensal, h=mesesAPrever)
plot(fcast_arima_6mth, xlab="Anos", ylab="Fluxo Mensal")
lines(tsMensalTest6mth, col="red")
```

Acurácia:
```{r}
accuracy(fcast_arima_6mth, tsMensalTest6mth)
```

## Método ARIMA em prospecções de longo prazo

### Para 1 ano

```{r}
mesesAPrever <- 12
```

Predição:
```{r, cache=TRUE}
fcast_arima_1yr <- forecast(arima_model_mensal, h=mesesAPrever)
plot(fcast_arima_1yr)
lines(tsMensalTest1yr, col="red")
```

Acurácia:
```{r}
accuracy(fcast_arima_1yr, tsMensalTest1yr)
```

## Método ARIMA - Conclusões

* Para a base de dados em questão, foi satisfatório para prospecções em médio prazo.

## Modelo Exponential Smoothing

Algo sobre.

* Error - Additive vs Multiplicative
* Trend - Additive vs Multiplicative 
* Season - Additive vs Multiplicative 

`ets()` sem parâmetros determina automaticamente.

Ver [@HyndmanAthanasopoulos201310]. O autor possui um livro exclusivamente sobre o assunto em [@HyndmanKoehlerOrdSnyder200807].


## Método Exponential Smoothing em Curto Prazo

```{r}
diasAPrever <- 30
```

Modelo:
```{r, cache=TRUE}
etsDiario <- ets(tsDiarioTrain)
```

Prospecção:
```{r, cache=TRUE}
fcastDiario30days <- forecast(etsDiario, h=diasAPrever)
```

Comparar predição com valores reais do conjunto de teste:
```{r}
plot(fcastDiario30days, xlab="Anos", ylab="Fluxo Mensal");
lines(tsDiarioTest30Days, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
```

Acurácia:
```{r}
accuracy(fcastDiario30days, tsDiarioTest30Days)
```

## Método Exponential Smoothing em Médio Prazo

### Para 6 meses
```{r}
mesesAPrever <- 6
```

Modelo:
```{r, cache=TRUE}
etsMensal <- ets(tsMensalTrain)
```

Prospecção:
```{r, cache=TRUE}
fcastMensal6mth <- forecast(etsMensal, h=mesesAPrever)
```

Comparar predição com valores reais do conjunto de teste:
```{r}
plot(fcastMensal6mth, xlab="Anos", ylab="Fluxo Mensal");
lines(tsMensalTest6mth, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
```

Acurácia:
```{r}
accuracy(fcastMensal6mth, tsMensalTest6mth)
```

## Método Exponential Smoothing em Longo Prazo

### Para 1 ano
```{r}
mesesAPrever <- 12
```

Prospecção:
```{r}
fcastMensal1yr <- forecast(etsMensal, h=mesesAPrever)
```

Comparar predição com valores reais do conjunto de teste:
```{r, cache=TRUE}
plot(fcastMensal1yr, include=60)
lines(tsMensalTest1yr, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
```

Acurácia:
```{r, cache=TRUE}
accuracy(fcastMensal1yr, tsMensalTest1yr)
```

### Usando transformação Box-cox
```{r, cache=TRUE}
lam <- BoxCox.lambda(tsMensalTrain)
etsMensal_boxcox <- ets(tsMensalTrain, additive=TRUE, lambda=lam)
fcastMensal1yr_boxcox <- forecast(etsMensal_boxcox,  h = mesesAPrever)

plot(fcastMensal1yr_boxcox, include=60)
lines(tsMensalTest1yr, col="red")
```

Acurácia:
```{r, cache=TRUE}
accuracy(fcastMensal1yr_boxcox, tsMensalTest1yr)
```

## STLF

```{r}
mesesAPrever <- 12
```

Dados com sazonalidade removida:
```{r}
tsMensal.stl <- stl(tsMensalTrain[,1], s.window=12)
# Seasonally adjusted data constructed by removing the seasonal component.
plot(seasadj(tsMensal.stl))
```

```{r}
stlf_model <- stlf(tsMensalTrain[,1])
stlf_fcast <- forecast(stlf_model, h=mesesAPrever)
plot(stlf_fcast)
lines(tsMensalTest1yr, col="red")
```

Acurácia:
```{r, cache=TRUE}
accuracy(stlf_fcast, tsMensalTest1yr)
```


## Referências