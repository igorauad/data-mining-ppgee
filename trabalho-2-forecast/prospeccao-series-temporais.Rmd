---
title: "Prospecção Séries Temporais"
author: 'G4: Edinaldo de Alencar / Igor Freire / Ramon Araújo / Ricardo Ribeiro'
date: "30 de outubro de 2014"
output:
  slidy_presentation:
    incremental: yes
    footer: "G4: Edinaldo de Alencar / Igor Freire / Ramon Araújo / Ricardo Ribeiro"
  beamer_presentation:
    incremental: yes
bibliography: bibliography.bib
---

## Importação da base de dados

```{r, echo=FALSE, message=FALSE}
# Pacote utilizado para leitura em formato de séries temporais:
library(zoo)

## Importar as bases de dados utilizando `read.zoo`

# A base de dados e os scripts R estão no mesmo diretório (o diretório atual)
setwd(paste("~/Documents/Mestrado/UFPA/Mineração de Dados/data-mining-ppgee/trabalho-2-forecast/", sep=""));
#setwd(paste("./", sep=""));

# Inicialmente, ler a base de dados diários como um data frame (através de read.csv)
dataframe_diario <- read.csv(file = "dataset_diario.csv", sep = ";", dec = ",", header = TRUE)
# Em seguida, converter para uma série temporal (lista indexada pela data)
dataset_diario <- zoo(as.matrix(dataframe_diario[, -1:-2]), as.Date(dataframe_diario[,1], format = "%d/%m/%y"))
# Obs: em "format" usa-se y minusculo, pois a data está no formato dd/mm/yy

# A função read.zoo() abaixo não retorna lista com vetores categóricos e numéricos ao mesmo tempo.
# Isto é, se houver dados categóricos e numéricos na base, os numéricos serão convertidos.
# Por isso, a base com dados diários não foi lida diretamente com read.zoo. A base com dados mensais 
# pode ser lida diretamente com read.zoo()
# Ler o .csv como uma série temporal (indexado pela data)
dataset_mensal <- read.zoo(file = "dataset_mensal.csv", sep = ";", dec = ",", header = TRUE, 
        index = 1, tz = "", FUN = as.yearmon, format = "%m/%Y", drop = FALSE)
# index ->  coluna do arquivo .csv que contém a data
# Obs: em "format" usa-se Y maiúsculo, pois a data está no formato mm/yyyy

### Notar que é necessário definir:

# - O caractere que separa as entradas no arquivo *.csv* (`sep =`)
# - O caractere separador de casas decimais do atributo numérico presente nas bases de dados (`dec =`)                
```

* `dataset_diario` é a base com valores de fluxos diários de 2002 a 2009. 
* `dataset_mensal` é a base com os valores de fluxo mensais de 1992 a 2009. 

**Nota:** a informação sobre os dias da semana é redundante, pois pode ser obtida através de:
```{r}
dia <- weekdays(index(dataset_diario))
```
Por isso, na leitura da base em `dataset_diario`, esta coluna foi ignorada.


<!-- Helper Functions -->

```{r, echo=FALSE}
# Funcao pra pegar a data em uma série temporal diária
getDate <- function(ts) {
  indices <- array()
  for (i in 1:length(ts)) {
    indices[i] <- which(dataset_diario == ts[i])
  }
  return(index(dataset_diario[indices]))
}

getDate2 <- function(ts) {
  indices <- array()
  for (i in 1:length(ts)) {
    indices[i] <- which(dataset_mensal == ts[i])
  }
  return(index(dataset_mensal[indices]))
}

dataByWeekday <- function(targetWeekday) {
  indices <- which(weekdays(index(dataset_diario)) == targetWeekday)
  return(dataset_diario[indices])
}

dataByMonthWeekday <- function(targetWeekday, targetMonth) {
  indices <- which(weekdays(index(dataset_diario)) == targetWeekday & months(index(dataset_diario)) == targetMonth)
  return(dataset_diario[indices])
}

isHoliday <- function(dataset) {
  holidays = c('01/01', '21/04', '01/05', '07/09', '12/10', '02/11', '15/11', '25/11', '31/12')
  # Nota: Talvez natal e ano novo não sejam de baixa consumo energetico
  # Declare vector for containing results
  returnVec <- array()
  for (i in 1:length(dataset)) {     
    if (is.element(format(index(dataset[i]), "%d/%m"), holidays)) {
      returnVec[i] = TRUE;
      } else {
        returnVec[i] = FALSE;
        }
    }
  
  dynamicHolidays = c( # carnaval
                      '11/02/02','12/02/02',
                      '03/03/03','04/03/03',
                      '23/02/04','24/02/04',
                      '07/02/05','08/02/05',
                      '27/02/06','28/02/06',
                      '19/02/07','20/02/07',
                      '04/02/08','05/02/08',
                      '23/02/09','24/02/09', 
                      # Pascoa              
                      '31/03/02',
                      '20/04/03',
                      '11/04/04',
                      '27/03/05',
                      '16/04/06',
                      '08/04/07',
                      '23/03/08',
                      '12/04/09'
                      )
  
  for (i in 1:length(dataset)) {     
    if (is.element(format(index(dataset[i]), "%d/%m/%y"), dynamicHolidays) && !returnVec[i]) {
      returnVec[i] = TRUE;
      }
    }
  
  return(returnVec);
  }

## Function to remove repeated entries in vector of labels

removeRepeated <- function (labels) {
  for (i in 2:length(labels)) {
    if (labels[i] == labels[i-1]) {
      labels[i] = ''
      }
    if(i-2 > 0) {
      if(labels[i] == labels[i-2]) {
        labels[i] = '';
        }
      }
    if(i-3 > 0) {
      if(labels[i] == labels[i-3]) {
        labels[i] = '';
        }
      }
    if(i-4 > 0) {
      if (labels[i] == labels[i-4]) {
        labels[i] = '';
      }
    }
    
    if(i-5 > 0) {
      if (labels[i] == labels[i-5]) {
        labels[i] = '';
        }
      }
    }
  return(labels);
}
getMonthLabels <- function(weekdaySeries) {
  
  labels <- removeRepeated(months(index(weekdaySeries)));    
  return(labels)
  }

getYearLabels <- function(weekdayMonthSeries) {
  
  labels <- removeRepeated(format(index(weekdayMonthSeries), "%Y"))
  return(labels)
  }
```


## Séries Temporais

Conversão dos dados para o formato de série temporal no R.

```{r, include=FALSE}
library(forecast)
```

#### Série Mensal:
```{r, cache=TRUE}
# Frequency --> número de observações por unidade de tempo 
# define a unidade de tempo (e.g. 12: unidade de tempo = ano)
tsMensal <- ts(dataset_mensal, frequency=12, start=1992)
```

```{r, echo=FALSE}
plot(tsMensal, xlab="Anos", ylab="Fluxo Mensal")
title('Dados Mensais')
```

#### Série Diária:
Série temporal diária
```{r, cache=TRUE}
tsDiario <- msts(dataset_diario, start=c(2002,1,1), seasonal.periods=c(7, 365.25))
```

```{r, echo=FALSE}
plot(tsDiario, xlab="Anos", ylab="Fluxo")
title('Dados Diários')
```

**Nota:** é importante observar os anos bissextos, 2004 e 2008.

## Inspeção dos Dados

### Série para um dia específico da semana
```{r, echo=FALSE}
# Dados para um determinado dia da semana 
weekdaySeries <- dataByWeekday("Segunda Feira")
plot(weekdaySeries, xaxt = 'n', xlab="Mes")
title("Segunda Feira")
axis_labels <- getMonthLabels(weekdaySeries)
axis(side=1, at=index(weekdaySeries), labels=axis_labels, las=2, cex.axis=0.5)
```

### Série para um dia e mês específico da semana 
```{r, echo=FALSE}
# Dados para um determinado dia da semana e mês
# Exemplo, quinta-feira 12 de outubro de 2006, feriado
# Exemplo, quinta-feira 02 de novembro de 2006, feriado
weekdayMonthSeries <- dataByMonthWeekday("Quinta Feira", "Outubro")
plot(weekdayMonthSeries, xaxt = 'n', xlab="Mes")
title("Quinta-Feira em Outubro")
axis_labels <- getYearLabels(weekdayMonthSeries)
axis(side=1, at=index(weekdayMonthSeries), labels=axis_labels, las=2, cex.axis=0.7)
```

**Observar** a influência dos feriados. Exemplo, 12 de outubro foi uma quinta-feira em 2006.

## Inspeção dos Dados - 2

A série temporal pode ser decomposta em:

* *Trend*: padrão de crescimento ao longo do tempo.
* *Seasonal*: padrão recorrente em um determinado período de tempo.
* *Irregular* (random): parte irregular (ruidosa), sem padrão sazonal ou tendência.


### Fluxo Mensal
```{r, echo=FALSE}
plot(decompose(tsMensal), xlab="Anos")
```

### Fluxo Diário
```{r, echo=FALSE}
plot(decompose(tsDiario), xlab="Anos")
```

### Observações
  1. Clara tendência (trend) de subida.
  2. Sazonalidade de 1 ano.
  3. No fluxo diário, há sazonalidade semanal.
  
## Inspeção dos Dados - 3
  
### Fluxo Diário para um intervalo arbitrário de 8 semanas
```{r, echo=FALSE}
tsDiario_8wWindow <- window(tsDiario, start=c(2008,5), end=c(2008,61))
plot(tsDiario_8wWindow, ylab="Fluxo Diário", xaxt = 'n', xlab="Dia")
title("Intervalo arbitrário de 8 semanas")
axis_labels <- weekdays(getDate(tsDiario_8wWindow))
axis(side=1, at=index(tsDiario_8wWindow), labels=axis_labels, las=2, cex.axis=0.75)
```


## Inspeção dos Dados - 4

### Auto-correlação
```{r}
acf(dataset_diario, col="red")
```

### Parcial:
```{r}
pacf(dataset_diario, col="red")
```










## Objetivos

Realizar prospecções de curto, médio e longo prazo.

### Curto Prazo
  * 30 Dias
  * 45 Dias
  
Para curto prazo, será utilizada a série temporal com dados diários (`tsDiario`). 
  
### Médio Prazo
  * 4 Meses 
  * 6 Meses
  
### Longo Prazo
  * 1 Ano
  * 2 Anos
  
Para médio e longo prazo, será utilizada a série temporal com dados mensais (`tsMensal`).






## Separação dos dados

Separação das séries temporais em conjuntos de treinamento e de testes.

### Curto Prazo (`tsDiario`)

#### Conjunto de Treinamento
```{r, cache=TRUE}
tsDiarioTrain <- window(tsDiario, end=c(2008,183)) # até 30/06/2008
```

```{r, echo=FALSE}
plot(tsDiarioTrain, xlab="Anos", ylab="Fluxo Diário")
```

<!-- Confirma se os dias estão corretos: -->

```{r, echo=FALSE, message=FALSE, results='hide'}
# Últimos dias da série de treinamento:
getDate(tail(tsDiarioTrain))
```

#### Conjuntos de Teste

##### 30 dias:
```{r, cache=TRUE}
# De 01/07/2008 a 30/07/2008
tsDiarioTest30Days <- window(tsDiario, start=c(2008,184), end=c(2008,213)) 
```

<!-- Confirma se os dias estão corretos: -->

```{r, echo=FALSE, message=FALSE, eval=FALSE}
# Checagem pra verificar se o eixo temporal em tsDiarioTest30Days está correto: 
plot(window(tsDiario, start=c(2008,170), end=c(2008,230)))
lines(tsDiarioTest30Days, col="red")
```


##### 45 dias:
```{r, cache=TRUE}
# 45 dias a partir De 1/1/2008
tsDiarioTest45Days <- window(tsDiario, start=c(2008,184), end=c(2008,228)) 
```

```{r, echo=FALSE, message=FALSE, eval=FALSE}
#### Checagem pra verificar se o eixo temporal em tsDiarioTest45Days está correto: 
plot(window(tsDiario, start=c(2008,170), end=c(2008,260)))
lines(tsDiarioTest45Days, col="red")
```

### Médio/Longo Prazo (`tsMensal`)

#### Conjunto de Treinamento
```{r, cache=TRUE}
tsMensalTrain <- window(tsMensal, end=c(2007, 12)) # De Jan 1992 a Dez 2007
```

```{r, echo=FALSE}
plot(tsMensalTrain, xlab="Anos", ylab="Fluxo Mensal")
```

#### Conjuntos de Teste

##### 4 meses:
```{r}
tsMensalTest4mth <- window(tsMensal, start=2008, end=c(2008, 4)) # De Jan 2006 a Mar 2006
```

##### 6 meses:
```{r}
tsMensalTest6mth <- window(tsMensal, start=2008, end=c(2008, 6)) # De Jan 2006 a Jun 2006
```

##### 1 ano:
```{r}
tsMensalTest1yr <- window(tsMensal, start=2008, end=c(2008, 12)) # De Jan 2006 a Jan 2007
```

##### 2 anos:
```{r}
tsMensalTest2yr <- window(tsMensal, start=2008, end=c(2009, 12)) # De Jan 2006 a Jan 2008
```





## Bibliotecas Utilizada

### Prospecções Estatísticas

ver [@hyndmanForecastingR] e [@practicalMachineLearningForecasting]:
```{r, message=FALSE}
library(forecast)
```

### Redes Neurais:
```{r, message=FALSE}
library(nnet)
```


## Estratégia de Avaliação dos Métodos
Apresenta-se a seguir:

* a predição proporcionada por diferentes métodos (curva vermelha).
* intervalos de predição correspondentes aos níveis de confiança 80% (em azul) e 95% (em cinza).
* acurácias **in-sample** e **out-of-sample**.

**Nota**:

* **in-sample**: medida no conjunto de treinamento.
* **out-of-sample**: medida no conjunto de testes.


## Acurácia

### MAPE:

Diferentemente do ME, MAE e RMSE, o medidor MAPE é independente da escala.

$$M = \frac{1}{n} \sum \limits_{t=1}^{n} \left| \frac{A_t - F_t}{A_t} \right|,$$ 

onde $A_t$ é o valor verdadeiro, $F_t$ é o valor predito e $n$ é o número de amostras temporais preditas.

Como desvantagem, o critério MAPE tem comportamento indefinido quando o valor verdadeiro $A_t=0$ (divisão por zero).

## Benchmark Métodos Estatísticos

<!-- Prospeccoes a curto Prazo -->

<!-- 30 dias -->

```{r, echo=FALSE}
diasAPrever <- 30
tsTrain <- tsDiarioTrain
tsTest <- tsDiarioTest30Days
# Média
f_mean <- meanf(tsTrain, h=diasAPrever)
mape_mean_accuracy <- accuracy(f_mean, tsTest)[,5]
# Naïve
f_naive <- naive(tsTrain, h=diasAPrever)
mape_naive_accuracy <- accuracy(f_naive, tsTest)[,5]
# Naïve Sazonal
f_seasonal_naive <- snaive(tsTrain, h=diasAPrever)
mape_naiveseaz_accuracy <- accuracy(f_seasonal_naive, tsTest)[,5]
# Drift
f_drift <- rwf(tsTrain, drift = TRUE, h=diasAPrever)
mape_drif_accuracy <- accuracy(f_drift, tsTest)[,5]
# Regressao
reg <- tslm(tsTrain ~ trend + season)
regfcast <- forecast(reg, h=diasAPrever)
reg_accuracy <- accuracy(regfcast, tsTest)[,5]
# Nota: ETS não é apropriado pra curto prazo


accuracies <- data.frame(mape_mean_accuracy, 
                         mape_naive_accuracy, 
                         mape_naiveseaz_accuracy,
                         mape_drif_accuracy,
                         reg_accuracy)

colnames(accuracies) <- c("Mean", "Näive", "N-Sazonal", "Drift", "Regressao")
```

### Curto prazo 
30 dias
```{r, echo=FALSE}
t(accuracies)
```





<!-- Prospeccoes a medio Prazo -->

<!-- Metodos simplistas -->

```{r, echo=FALSE, cache=TRUE}
mesesAPrever <- 4
# Média
f_mean <- meanf(tsMensalTrain, h=mesesAPrever)
mape_mean_accuracy <- accuracy(f_mean, tsMensalTest1yr)[,5]
# Naïve
f_naive <- naive(tsMensalTrain, h=mesesAPrever)
mape_naive_accuracy <- accuracy(f_naive, tsMensalTest1yr)[,5]
# Naïve Sazonal
f_seasonal_naive <- snaive(tsMensalTrain, h=mesesAPrever)
mape_naiveseaz_accuracy <- accuracy(f_seasonal_naive, tsMensalTest1yr)[,5]
# Drift
f_drift <- rwf(tsMensalTrain, drift = TRUE, h=mesesAPrever)
mape_drif_accuracy <- accuracy(f_drift, tsMensalTest1yr)[,5]

accuracies <- data.frame(mape_mean_accuracy, 
                         mape_naive_accuracy, 
                         mape_naiveseaz_accuracy,
                         mape_drif_accuracy)

colnames(accuracies) <- c("Mean", "Näive", "N-Sazonal", "Drift")
```


### Médio prazo (4 meses)
```{r, echo=FALSE}
t(accuracies)
```



<!-- Prospeccoes a medio Prazo -->

<!-- 12 meses -->


```{r, echo=FALSE, cache=TRUE}
mesesAPrever <- 12
tsTrain <- tsMensalTrain
tsTest <- tsMensalTest1yr

# Média
f_mean <- meanf(tsTrain, h=mesesAPrever)
mape_mean_accuracy <- accuracy(f_mean, tsTest)[,5]
# Naïve
f_naive <- naive(tsTrain, h=mesesAPrever)
mape_naive_accuracy <- accuracy(f_naive, tsTest)[,5]
# Naïve Sazonal
f_seasonal_naive <- snaive(tsTrain, h=mesesAPrever)
mape_naiveseaz_accuracy <- accuracy(f_seasonal_naive, tsTest)[,5]
# Drift
f_drift <- rwf(tsTrain, drift = TRUE, h=mesesAPrever)
mape_drif_accuracy <- accuracy(f_drift, tsTest)[,5]
# Regressao Linear
reg <- tslm(tsTrain ~ trend + season)
regfcast <- forecast(reg, h=mesesAPrever)
reg_accuracy <- accuracy(regfcast, tsTest)[,5]
# ETS
etsMensal <- ets(tsTrain)
fcastMensal <- forecast(etsMensal, h=mesesAPrever)
ets_accuracy <- accuracy(fcastMensal, tsTest)[,5]

accuracies <- data.frame(mape_mean_accuracy, 
                         mape_naive_accuracy, 
                         mape_naiveseaz_accuracy,
                         mape_drif_accuracy,
                         reg_accuracy,
                         ets_accuracy)

colnames(accuracies) <- c("Mean", "Näive", "N-Sazonal", "Drift", "Regressao", "ETS")
```

### Longo prazo 
1 ano
```{r, echo=FALSE}
t(accuracies)
```

<!-- 24 meses -->

```{r, echo=FALSE, cache=TRUE}
mesesAPrever <- 24
tsTrain <- tsMensalTrain
tsTest <- tsMensalTest2yr

# Média
f_mean <- meanf(tsTrain, h=mesesAPrever)
mape_mean_accuracy <- accuracy(f_mean, tsTest)[,5]
# Naïve
f_naive <- naive(tsTrain, h=mesesAPrever)
mape_naive_accuracy <- accuracy(f_naive, tsTest)[,5]
# Naïve Sazonal
f_seasonal_naive <- snaive(tsTrain, h=mesesAPrever)
mape_naiveseaz_accuracy <- accuracy(f_seasonal_naive, tsTest)[,5]
# Drift
f_drift <- rwf(tsTrain, drift = TRUE, h=mesesAPrever)
mape_drif_accuracy <- accuracy(f_drift, tsTest)[,5]
# Regressao Linear
reg <- tslm(tsTrain ~ trend + season)
regfcast <- forecast(reg, h=mesesAPrever)
reg_accuracy <- accuracy(regfcast, tsTest)[,5]
# ETS
fcastMensal <- forecast(etsMensal, h=mesesAPrever)
ets_accuracy <- accuracy(fcastMensal, tsTest)[,5]

accuracies <- data.frame(mape_mean_accuracy, 
                         mape_naive_accuracy, 
                         mape_naiveseaz_accuracy,
                         mape_drif_accuracy,
                         reg_accuracy,
                         ets_accuracy)

colnames(accuracies) <- c("Mean", "Näive", "N-Sazonal", "Drift", "Regressao", "ETS")
```

2 anos
```{r, echo=FALSE}
t(accuracies)
```



## Modelo auto-regressivo (AR)

Em um modelo de auto-regressão, prevemos a variável de interesse usando uma combinação linear dos valores passados da variável.

Assim, um modelo auto-regressivo de ordem $p$, denotado por $AR(p)$, pode ser escrito como:

$y_t = c + \varphi_1 y_{t-1} + \varphi_2 y_{t-2} + \dots +  \varphi_p y_{t-p} + e_t,$

onde $c$ é uma constante, $e_t$ o ruído branco, e, os valores defasados de $y_t$ são os preditores.

Para um modelo $AR(1)$, tem-se $\varphi_1\in(-1,1)$

Para um modelo $AR(2)$, tem-se $\varphi_1,\varphi_2\in(-1,1)$ com $\varphi_1 + \varphi_2 < 1$ e $\varphi_2 - \varphi_1 < 1$

## Modelos médias-móveis (MA)

Ao invés de usar valores passados da variável de previsão em uma regressão, o modelo de médias-móveis usa erros de previsão do passado em um modelo de regressão-like.

$y_t = c + e_t + \theta_1 e_{t-1} + \theta_2 e_{t-2} + \dots +  \theta_q e_{t-q}.$

Esse modelo tem ordem $q$ e é denotado por $MA(q)$.

Para um modelo $MA(1)$, tem-se $\theta_1\in(-1,1)$

Para um modelo $MA(2)$, tem-se $\theta_1,\theta_2\in(-1,1)$ com $\theta_1 + \theta_2 > -1$ e $\theta_1 - \theta_2 < 1$

## Relação entre modelos AR e MA

É possível escrever o modelo $AR(p)$ como um modelo $MA(\infty)$. Em particular para um modelo $AR(1)$, vem:

$y_t = \varphi_1 y_{t-1} + e_t$

$y_t = \varphi_1 ( \varphi_1 y_{t-2} + e_{t-1} ) + e_t$


$y_t = \varphi_1^2 y_{t-2} + \varphi_1 e_{t-1} + e_t$

$y_t = \varphi_1^3 y_{t-3} + \varphi_1^2 e_{t-2}  + \varphi_1 e_{t-1} + e_t$

e assim por diante. Onde $\varphi_1\in(-1,1)$





## Modelo ARIMA

ARIMA (*Autoregressive Integrated Moving Average*)

* Combinação dos modelos:
    * auto-regressivo (AR)
    * médias-móveis (MA)

* Método ARMA, acrescido da etapa de integração (I).

* Caso a série temporal seja estacionária, o método se reduz ao ARMA.

### Equação de Predição

$$y(t) = \sum_{i=1}^{p}\varphi_ix(t-i) + \sum_{j=1}^{q}\theta_j\epsilon(t-j)$$

### Notação
$ARIMA(p,d,q)$, onde:

* p = número de valores passados da variável (AR)

* d = número de diferenças não-sazonais

* q = número de rerros de predição passados (MA)



## Método ARIMA em prospecções de médio prazo

### Para 4 meses

```{r}
mesesAPrever <- 4
```

Modelo:
```{r, cache=TRUE}
arima_model_mensal <- auto.arima(tsMensalTrain)
```

Predição:
```{r}
fcast_arima_4mth <- forecast(arima_model_mensal, h=mesesAPrever)
plot(fcast_arima_4mth, xlab="Anos", ylab="Fluxo Mensal", include=36)
lines(tsMensalTest4mth, col="red")
```

Acurácia:
```{r}
accuracy(fcast_arima_4mth, tsMensalTest4mth)
```

### Para 6 meses

```{r, cache=TRUE}
mesesAPrever <- 6
```

Predição:
```{r, cache=TRUE}
fcast_arima_6mth <- forecast(arima_model_mensal, h=mesesAPrever)
```

```{r}
plot(fcast_arima_6mth, xlab="Anos", ylab="Fluxo Mensal", include=36)
lines(tsMensalTest6mth, col="red")
```

Acurácia:
```{r}
accuracy(fcast_arima_6mth, tsMensalTest6mth)
```

## Método ARIMA em prospecções de longo prazo

### Para 1 ano

```{r, cache=TRUE}
mesesAPrever <- 12
```

Predição:
```{r, cache=TRUE}
fcast_arima_1yr <- forecast(arima_model_mensal, h=mesesAPrever)
```

```{r}
plot(fcast_arima_1yr, include=48)
lines(tsMensalTest1yr, col="red")
```

Acurácia:
```{r}
accuracy(fcast_arima_1yr, tsMensalTest1yr)
```






## Modelo TBATS

* Técnica recente, publicada em 2011 [@tbats_paper2011].

* A sigla TBATS é composta das iniciais das técnicas utilizadas: Trigonométrica, transformação Box-cox, correção de erro pela técnica ARMA, e componentes Trend e Sazonal.

* Desenvolvido para séries temporais com características especiais de sazonalidade.


### Justificativa

* Por inspeção visual do fluxo diário, suspeitou-se que a série temporal apresenta sazonalidades semanal e anual.

### Modelo TBATS, a partir da série multi-sazonal do conjunto de treinamento:
```{r, cache=TRUE}
tbats_model <- tbats(tsDiarioTrain)
#tbats_model <- tbats(window(tsDiarioTrain, start=2005))
```

#### Decomposição do fluxo diário em termos trend+season pelo método TBATS
```{r}
plot(tbats_model)
```


O método TBATS é indicado para a previsão do fluxo diário, pois:

1. Sazonalidades múltiplas: semanal e anual

2. Sazonalidade semanal é de alta frequência





## Método TBATS em prospecções de Curto Prazo

### Para 30 dias

```{r}
diasAPrever <- 30
```

Predição:
```{r}
tbats_fc30Days <- forecast(tbats_model, h=diasAPrever)
plot(tbats_fc30Days, include = 120)
lines(tsDiarioTest30Days, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
```

Acurácia:
```{r}
accuracy(tbats_fc30Days, tsDiarioTest30Days)
```


## Método TBATS em prospecções de Curto Prazo

### Para 45 dias

```{r}
diasAPrever <- 45
```

Predição:
```{r}
tbats_fc45Days <- forecast(tbats_model, h=diasAPrever)
plot(tbats_fc45Days, include = 120)
lines(tsDiarioTest45Days, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
```

Acurácia:
```{r}
accuracy(tbats_fc45Days, tsDiarioTest45Days)
```









## *Exponential Smoothing*

* Médias móveis simples pondera igualmente as observações passadas em uma série temporal.
* Exponential smoothing atribui pesos que decrescem exponencialmente ao longo do tempo, levando em consideração:
    * Erro
    * Tendência
    * Sazonalidade
* Estes parâmetros podem ser escolhidos como (e.g. tendência $T_h$, assumindo um termo de nível $l$ e termo de crescimento $b$, para $h$ períodos temporais e $0 < \phi < 1$):
    * Nulo:    $T_h = l$ 
    * Aditivo:    $T_h = l + bh$
    * Aditivo amortecido:     $T_h = l + \left( \phi + \phi^2 + \cdots + \phi^h \right)b$
    * Multiplicativo:     $T_h = l b^h$
    * Multiplicativo amortecido:    $T_h = l b^{\left( \phi + \phi^2 + \cdots + \phi^h \right)}$
  

## *Exponential Smoothing* - 2

Ver [@HyndmanAthanasopoulos201310]. O autor possui um livro exclusivamente sobre o assunto em [@HyndmanKoehlerOrdSnyder200807].

![ETS](./figs/ets.png)

Para cada um dos 15 métodos, há dois modelos possíveis: com erro aditivo e com erro multiplicativo. 

### Há, portanto, 30 métodos distintos.

## *Exponential Smoothing* no R

* A função `ets(ts)` sem argumentos além da série temporal `ts` determina automaticamente o método apropriado.
* O algoritmo avalia os 30 métodos e busca aquele que tiver o menor AIC.
    * AIC - "Akaike information criterion": uma estimativa da informação perdida quando um determinado modelo é usado para representar o verdadeiro processo que gera a série temporal.
* Ao final, o objeto retornado por `ets` apresenta o modelo escolhido e o AIC resultante.
* A função `ets` não trabalha com séries cuja sazonalidade é superior a 24 unidades temporais. Portanto, será utilizada somente pra prospecções realizadas com dados mensais (sazonalidade = 12).
* O modelo `ets` parametrizado automáticamente deve dar resultados muito precisos para prospecções de poucos pontos (por exemplo, 4 pontos). 

## Método *Exponential Smoothing* em Médio Prazo

### Para 6 meses
```{r}
mesesAPrever <- 6
```

Modelo:
```{r, cache=TRUE}
etsMensal <- ets(tsMensalTrain)
```

Prospecção:
```{r, cache=TRUE}
fcastMensal6mth <- forecast(etsMensal, h=mesesAPrever)
```

Comparar predição com valores reais do conjunto de teste:
```{r}
plot(fcastMensal6mth, xlab="Anos", ylab="Fluxo Mensal", include = 36);
lines(tsMensalTest6mth, col="red")
legend("topleft",legend=c("Real"),col=2,lty=1)
```

Acurácia:
```{r}
accuracy(fcastMensal6mth, tsMensalTest6mth)
```


# Prospecção a Longo Prazo

## Transformação Box-Cox

Há um fator multiplicativo no fator sazonal. Uma transformação Box-Cox demonstrou ser apropriada.

* $W_t = \begin{cases} \log\left(y_t\right) & \lambda = 0\\ \frac{(y_t^\lambda - 1)}{\lambda} & \lambda \neq 0\end{cases}$

### Série original
```{r}
plot(tsMensalTrain, xlab="Anos", ylab="Fluxo Mensal")
```

### Série transformada
Calcula-se o fator $\lambda$ para a transformação:
```{r, cache=TRUE}
lam <- BoxCox.lambda(tsMensalTrain)
```

Série Resultante:
```{r, cache=TRUE}
tsMensalBoxCox <- BoxCox(x = tsMensalTrain, lam)
```

```{r}
plot(tsMensalBoxCox, col="red")
```



## Prospecção com decomposição sazonal de Loess - STLF

1. Aplica-se a decomposição STL
1. Remove-se a sazonalidade da série temporal
2. Um modelo é treinado na série resultante
3. Faz-se a prospecção
4. Adiciona-se novamente o último período da sazonalidade estimada nos resultados

```{r}
mesesAPrever <- 24
```

Dados com sazonalidade removida:
```{r}
tsMensal.stl <- stl(tsMensalTrain[,1], s.window=12)
# Seasonally adjusted data constructed by removing the seasonal component.
plot(seasadj(tsMensal.stl))
```

```{r}
stlf_model <- stlf(tsMensalTrain[,1], lambda = lam)
stlf_fcast <- forecast(stlf_model, h=mesesAPrever)
plot(stlf_fcast, xlab="Anos", ylab="Fluxo Mensal")
lines(tsMensalTest2yr, col="red")
```

Acurácia:
```{r, cache=TRUE}
accuracy(stlf_fcast, tsMensalTest1yr)
```


## Referências



